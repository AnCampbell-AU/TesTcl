{
  "name": "TesTcl - a library for unit testing BIG-IP iRules",
  "tagline": "when you don't have the balls to test your iRules directly in production",
  "body": "# Introduction\r\n\r\n**TesTcl** is a [Tcl](http://en.wikipedia.org/wiki/Tcl) library for unit testing\r\n[iRules](https://devcentral.f5.com/HotTopics/iRules/tabid/1082202/Default.aspx) which \r\nare used when configuring [F5 BIG-IP](http://www.f5.com/products/big-ip/) devices.\r\n\r\n## News\r\n- 29th April 2016 - Version [1.0.9](https://github.com/landro/TesTcl/releases) released\r\n- 16th December 2015 - Version [1.0.8](https://github.com/landro/TesTcl/releases) released\r\n- 7th August 2015 - Version [1.0.7](https://github.com/landro/TesTcl/releases) released\r\n- 2nd September 2014 - Version [1.0.6](https://github.com/landro/TesTcl/releases) released\r\n- 27th July 2014 - Version [1.0.5](https://github.com/landro/TesTcl/releases) released \r\n\r\n## Getting started\r\n\r\nIf you're familiar with unit testing and [mocking](http://en.wikipedia.org/wiki/Mock_object) in particular,\r\nusing TesTcl should't be to hard. Check out the examples below:\r\n\r\n### Simple example\r\n\r\nLet's say you want to test the following simple iRule found in *simple_irule.tcl*:\r\n\r\n```tcl\r\nrule simple {\r\n\r\n  when HTTP_REQUEST {\r\n    if { [HTTP::uri] starts_with \"/foo\" } {\r\n      pool foo\r\n    } else {\r\n      pool bar\r\n    }\r\n  }\r\n\r\n  when HTTP_RESPONSE {\r\n    HTTP::header remove \"Vary\"\r\n    HTTP::header insert Vary \"Accept-Encoding\"\r\n  }\r\n\r\n}\r\n```\r\n\r\nNow, create a file called *test_simple_irule.tcl* containing the following lines:\r\n\r\n```tcl\r\npackage require -exact testcl 1.0.9\r\nnamespace import ::testcl::*\r\n\r\n# Comment in to enable logging\r\n#log::lvSuppressLE info 0\r\n\r\nit \"should handle request using pool bar\" {\r\n  event HTTP_REQUEST\r\n  on HTTP::uri return \"/bar\"\r\n  endstate pool bar\r\n  run simple_irule.tcl simple\r\n}\r\n\r\nit \"should handle request using pool foo\" {\r\n  event HTTP_REQUEST\r\n  on HTTP::uri return \"/foo/admin\"\r\n  endstate pool foo\r\n  run simple_irule.tcl simple\r\n}\r\n\r\nit \"should replace existing Vary http response headers with Accept-Encoding value\" {\r\n  event HTTP_RESPONSE\r\n  verify \"there should be only one Vary header\" 1 == {HTTP::header count vary}\r\n  verify \"there should be Accept-Encoding value in Vary header\" \"Accept-Encoding\" eq {HTTP::header Vary}\r\n  HTTP::header insert Vary \"dummy value\"\r\n  HTTP::header insert Vary \"another dummy value\"\r\n  run irules/simple_irule.tcl simple\r\n}\r\n```\r\n\r\n#### Installing JTcl including jtcl-irule extensions\r\n\r\n##### Install JTcl\r\nDownload [JTcl](http://jtcl.kenai.com/), unzip it and add it to your path.\r\n\r\n##### Add jtcl-irule to your JTcl installation\r\nAdd the [jtcl-irule](http://landro.github.com/jtcl-irule/) extension to JTcl. If you don't have the time to build it yourself, you can download the \r\njar artifact from the [downloads](https://github.com/landro/TesTcl/downloads) section or you can use the direct [link](https://github.com/downloads/landro/TesTcl/jtcl-irule.jar).\r\nNext, copy the jar file into the directory where you installed JTcl.\r\nAdd jtcl-irule to the classpath in _jtcl_ or _jtcl.bat_.\r\n**IMPORTANT!** Make sure you place the _jtcl-irule.jar_ on the classpath **before** the standard jtcl-<version>.jar\r\n\r\n###### MacOS X and Linux\r\n\r\nOn MacOs X and Linux, this can be achieved by putting the following line just above the last line in the jtcl shell script\r\n\r\n    export CLASSPATH=$dir/jtcl-irule.jar:$CLASSPATH\r\n    \r\n###### Windows\r\n\r\nOn Windows, modify the following line in jtcl.bat from \r\n\r\n    set cp=\"%dir%\\jtcl-%jtclver%.jar;%CLASSPATH%\"\r\n\r\nto\r\n\r\n    set cp=\"%dir%\\jtcl-irule.jar;%dir%\\jtcl-%jtclver%.jar;%CLASSPATH%\"\r\n\r\n##### Verify installation\r\n\r\nCreate a script file named *test_jtcl_irule.tcl* containing the following lines \r\n\r\n```tcl\r\nif {\"aa\" starts_with \"a\"} {\r\n  puts \"The jtcl-irule extension has successfully been installed\"\r\n}\r\n```\r\n\r\nand execute it using \r\n\r\n    jtcl test_jtcl_irule.tcl\r\n\r\nYou should get a success message.\r\n\r\n##### Add the testcl library to your library path\r\nDownload latest [TesTcl distribution](https://github.com/landro/TesTcl/releases) from github containing all the files (including examples) found in the project.\r\nUnzip, and add unzipped directory to the [TCLLIBPATH](http://jtcl.kenai.com/gettingstarted.html) environment variable:\r\n\r\n    export TCLLIBPATH=whereever/TesTcl-1.0.9\r\n\r\nIn order to run this example, type in the following at the command-line:\r\n\r\n    >jtcl test_simple_irule.tcl\r\n\r\nThis should give you the following output:\r\n\r\n    **************************************************************************\r\n    * it should handle request using pool bar\r\n    **************************************************************************\r\n    -> Test ok\r\n\r\n    **************************************************************************\r\n    * it should handle request using pool foo\r\n    **************************************************************************\r\n    -> Test ok\r\n\r\n    **************************************************************************\r\n    * it should replace existing Vary http response headers with Accept-Encoding value\r\n    **************************************************************************\r\n    verification of 'there should be only one Vary header' done.\r\n    verification of 'there should be Accept-Encoding value in Vary header' done.\r\n    -> Test ok\r\n\r\n#### Explanations\r\n\r\n- Require the **testcl** package and import the commands and variables found in the **testcl** namespace to use it.\r\n- Enable or disable logging\r\n- Add the specification tests\r\n  - Describe every _it_ statement as precisely as possible. It serves as documentation.\r\n  - Add an _event_ . **This is mandatory.**\r\n  - Add one or several _on_ statements to setup expectations/mocks. If you don't care about the return value, return \"\".\r\n  - Add an _endstate_. This could be a _pool_, _HTTP::respond_, _HTTP::redirect_ or any other function call (see [link](https://devcentral.f5.com/tech-tips/articles/-the101-irules-101-routing#.UW0OwoLfeN4)).\r\n  - Add a _verify_. The verifications will be run immediately after the iRule execution. Describe every verification as precisely as possible, add as many *verification*s as needed in your particular test scenario.\r\n  - Add an HTTP::header initialization if you are testing modification of HTTP headers (stubs/mocks are provided for all commands in HTTP namespace).\r\n  - Add a _run_ statement in order to actually run the Tcl script file containing your iRule. **This is mandatory.**\r\n\r\n##### A word on the TesTcl commands #####\r\n\r\n- _it_ statement takes two arguments, description and code block to execute as test case.\r\n- _event_ statement takes a single argument - event type. Supported values are [all standard HTTP, TCP and IP events .](https://devcentral.f5.com/wiki/irules.Events.ashx)\r\n- _on_ statement has the following syntax: _on_ ... (return|error) result\r\n- _endstate_ statement accepts 2 to 5 arguments which are matched with command to stop processing iRule with success in test case evaluation.\r\n- _verify_ statement takes four arguments. Syntax: _verify_ \"DESCRIPTION\" value _CONDITION_ {verification code}\r\n  - _description_ is displayed during verification execution\r\n  - _value_ is expected result of verification code\r\n  - _condition_ is operator used during comparison of _value_ with code result (ex. ==, !=, eq).\r\n  - _verification_code_ is code to evaluate after iRule execution\r\n- _run_ statement takes two arguments, file name of iRule source and name of iRule to execute\r\n\r\n##### A word on stubs or mockups (you choose what to call 'em)#####\r\n\r\n###### HTTP namespace ######\r\nMost of the other commands in the HTTP namespace have been implemented. We've done our best, but might have missed some details. Look at the sourcecode if \r\nyou wonder what is going on in the mocks.\r\nIn particular, the [HTTP::header](https://devcentral.f5.com/wiki/irules.HTTP__header.ashx) mockup implementation should work as expected.\r\nHowever _insert_modssl_fields_ subcommand is not supported in current version.\r\n\r\n###### URI namespace ######\r\nPartial support for \r\n\r\n - [URI::encode](https://devcentral.f5.com/wiki/iRules.URI__encode.ashx) \r\n\r\n###### GLOBAL namespace ######\r\nSupport for\r\n\r\n - [getfield](https://devcentral.f5.com/wiki/iRules.getfield.ashx)\r\n - [log](https://devcentral.f5.com/wiki/iRules.log.ashx) \r\n\r\n#### Avoiding code duplication using the before command\r\n\r\nIn order to avoid code duplication, one can use the _before_ command.\r\nThe argument passed to the _before_ command will be executed _before_ the following _it_ specifications.\r\n\r\nNB! Be carefull with using _on_ commands in _before_. If there will be another definition of the same expectation in _it_ statement, only first one will be in use (this one set in _before_).\r\n\r\nUsing the _before_ command, *test_simple_irule.tcl* can be rewritten as:\r\n\r\n```tcl\r\npackage require -exact testcl 1.0.9\r\nnamespace import ::testcl::*\r\n\r\n# Comment in to enable logging\r\n#log::lvSuppressLE info 0\r\n\r\nbefore {\r\n  event HTTP_REQUEST\r\n}\r\n\r\nit \"should handle request using pool bar\" {\r\n  on HTTP::uri return \"/bar\"\r\n  endstate pool bar\r\n  run simple_irule.tcl simple\r\n}\r\n\r\nit \"should handle request using pool foo\" {\r\n  on HTTP::uri return \"/foo/admin\"\r\n  endstate pool foo\r\n  run simple_irule.tcl simple\r\n}\r\n\r\nit \"should replace existing Vary http response headers with Accept-Encoding value\" {\r\n  # NB! override event type set in before\r\n  event HTTP_RESPONSE\r\n\r\n  verify \"there should be only one Vary header\" 1 == {HTTP::header count vary}\r\n  verify \"there should be Accept-Encoding value in Vary header\" \"Accept-Encoding\" eq {HTTP::header Vary}\r\n  HTTP::header insert Vary \"dummy value\"\r\n  HTTP::header insert Vary \"another dummy value\"\r\n  run irules/simple_irule.tcl simple\r\n}\r\n```\r\n\r\nOn a side note, it's worth mentioning that there is no _after_ command, since we're always dealing with mocks.\r\n\r\n### Advanced example\r\n\r\nLet's have a look at a more advanced iRule (advanced_irule.tcl):\r\n\r\n```tcl\r\nrule advanced {\r\n\r\n  when HTTP_REQUEST {\r\n\r\n    HTTP::header insert X-Forwarded-SSL true\r\n\r\n    if { [HTTP::uri] eq \"/admin\" } {\r\n      if { ([HTTP::username] eq \"admin\") && ([HTTP::password] eq \"password\") } {\r\n        set newuri [string map {/admin/ /} [HTTP::uri]]\r\n        HTTP::uri $newuri\r\n        pool pool_admin_application\r\n      } else {\r\n        HTTP::respond 401 WWW-Authenticate \"Basic realm=\\\"Restricted Area\\\"\"\r\n      }\r\n    } elseif { [HTTP::uri] eq \"/blocked\" } {\r\n      HTTP::respond 403\r\n    } elseif { [HTTP::uri] starts_with \"/app\"} {\r\n      if { [active_members pool_application] == 0 } {\r\n        if { [HTTP::header User-Agent] eq \"Apache HTTP Client\" } {\r\n          HTTP::respond 503\r\n        } else {\r\n          HTTP::redirect \"http://fallback.com\"\r\n        }\r\n      } else {\r\n        set newuri [string map {/app/ /} [HTTP::uri]]\r\n        HTTP::uri $newuri\r\n        pool pool_application\r\n      }\r\n    } else {\r\n      HTTP::respond 404\r\n    }\r\n\r\n  }\r\n\r\n}\r\n```\r\n\r\nThe specs for this iRule would look like this:\r\n\r\n```tcl\r\npackage require -exact testcl 1.0.9\r\nnamespace import ::testcl::*\r\n\r\n# Comment out to suppress logging\r\n#log::lvSuppressLE info 0\r\n\r\nbefore {\r\n  event HTTP_REQUEST\r\n}\r\n\r\nit \"should handle admin request using pool admin when credentials are valid\" {\r\n  HTTP::uri \"/admin\"\r\n  on HTTP::username return \"admin\"\r\n  on HTTP::password return \"password\"\r\n  endstate pool pool_admin_application\r\n  run irules/advanced_irule.tcl advanced\r\n}\r\n\r\nit \"should ask for credentials when admin request with incorrect credentials\" {\r\n  HTTP::uri \"/admin\"\r\n  HTTP::header insert Authorization \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\"\r\n  verify \"user Aladdin\" \"Aladdin\" eq {HTTP::username}\r\n  verify \"password 'open sesame'\" \"open sesame\" eq {HTTP::password}\r\n  verify \"WWW-Authenticate header is 'Basic realm=\\\"Restricted Area\\\"'\" \"Basic realm=\\\"Restricted Area\\\"\" eq {HTTP::header \"WWW-Authenticate\"}\r\n  verify \"response status code is 401\" 401 eq {HTTP::status}\r\n  run irules/advanced_irule.tcl advanced\r\n}\r\n\r\nit \"should ask for credentials when admin request without credentials\" {\r\n  HTTP::uri \"/admin\"\r\n  verify \"WWW-Authenticate header is 'Basic realm=\\\"Restricted Area\\\"'\" \"Basic realm=\\\"Restricted Area\\\"\" eq {HTTP::header \"WWW-Authenticate\"}\r\n  verify \"response status code is 401\" 401 eq {HTTP::status}\r\n  run irules/advanced_irule.tcl advanced\r\n}\r\n\r\nit \"should block access to uri /blocked\" {\r\n  HTTP::uri \"/blocked\"\r\n  endstate HTTP::respond 403\r\n  run irules/advanced_irule.tcl advanced\r\n}\r\n\r\nit \"should give apache http client a correct error code when app pool is down\" {\r\n  HTTP::uri \"/app\"\r\n  on active_members pool_application return 0\r\n  HTTP::header insert User-Agent \"Apache HTTP Client\"\r\n  endstate HTTP::respond 503\r\n  run irules/advanced_irule.tcl advanced\r\n}\r\n\r\nit \"should give other clients then apache http client redirect to fallback when app pool is down\" {\r\n  HTTP::uri \"/app\"\r\n  on active_members pool_application return 0\r\n  HTTP::header insert User-Agent \"Firefox 13.0.1\"\r\n  verify \"response status code is 302\" 302 eq {HTTP::status}\r\n  verify \"Location header is 'http://fallback.com'\" \"http://fallback.com\" eq {HTTP::header Location}\r\n  run irules/advanced_irule.tcl advanced\r\n}\r\n\r\nit \"should give handle app request using app pool when app pool is up\" {\r\n  HTTP::uri \"/app/form?test=query\"\r\n  on active_members pool_application return 2\r\n  endstate pool pool_application\r\n  verify \"result uri is /form?test=query\" \"/form?test=query\" eq {HTTP::uri}\r\n  verify \"result path is /form\" \"/form\" eq {HTTP::path}\r\n  verify \"result query is test=query\" \"test=query\" eq {HTTP::query}\r\n  run irules/advanced_irule.tcl advanced\r\n}\r\n\r\nit \"should give 404 when request cannot be handled\" {\r\n  HTTP::uri \"/cannot_be_handled\"\r\n  endstate HTTP::respond 404\r\n  run irules/advanced_irule.tcl advanced\r\n}\r\n\r\nstats\r\n```\r\n\r\n### Modification of HTTP headers example\r\n\r\nLet's have a look at another iRule (headers_irule.tcl):\r\n\r\n```tcl    \r\nrule headers {\r\n\r\n  #notify backend about SSL using X-Forwarded-SSL http header\r\n  #if there is client certificate put common name into X-Common-Name-SSL http header\r\n  #if not make sure X-Common-Name-SSL header is not set\r\n  when HTTP_REQUEST {\r\n    HTTP::header insert X-Forwarded-SSL true\r\n    HTTP::header remove X-Common-Name-SSL\r\n    \r\n    if { [SSL::cert count] > 0 } {\r\n      set ssl_cert [SSL::cert 0]\r\n      set subject [X509::subject $ssl_cert]\r\n      set cn \"\"\r\n      foreach { label value } [split $subject \",=\"] {\r\n        set label [string toupper [string trim $label]]\r\n        set value [string trim $value]\r\n        \r\n        if { $label == \"CN\" } {\r\n          set cn \"$value\"\r\n          break\r\n        }\r\n      }\r\n    \r\n      HTTP::header insert X-Common-Name-SSL \"$cn\"\r\n    }\r\n  }\r\n\r\n}\r\n```\r\n\r\nThe example specs for this iRule would look like this:\r\n\r\n```tcl\r\npackage require -exact testcl 1.0.9\r\nnamespace import ::testcl::*\r\n\r\n# Comment out to suppress logging\r\n#log::lvSuppressLE info 0\r\n\r\nbefore {\r\n  event HTTP_REQUEST\r\n  verify \"There should be always set HTTP header X-Forwarded-SSL to true\" true eq {HTTP::header X-Forwarded-SSL}\r\n}\r\n\r\nit \"should remove X-Common-Name-SSL header from request if there was no client SSL certificate\" {\r\n  HTTP::header insert X-Common-Name-SSL \"testCommonName\"\r\n  on SSL::cert count return 0\r\n  verify \"There should be no X-Common-Name-SSL\" 0 == {HTTP::header exists X-Common-Name-SSL}\r\n  run irules/headers_irule.tcl headers\r\n}\r\n\r\nit \"should add X-Common-Name-SSL with Common Name from client SSL certificate if it was available\" {\r\n  on SSL::cert count return 1\r\n  on SSL::cert 0 return {}\r\n  on X509::subject [SSL::cert 0] return \"CN=testCommonName,DN=abc.de.fg\"\r\n  verify \"X-Common-Name-SSL HTTP header value is the same as CN\" \"testCommonName\" eq {HTTP::header X-Common-Name-SSL}\r\n  run irules/headers_irule.tcl headers\r\n}\r\n```\r\n\r\n### Classes Example\r\n\r\nTesTcl has partial support for the `class` command. For example, we could test the following rule:\r\n\r\n```tcl\r\nrule classes {\r\n  when HTTP_REQUEST {\r\n    if { [class match [IP::remote_addr] eq blacklist] } {\r\n      drop\r\n    } else {\r\n      pool main-pool\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nwith code that looks like this\r\n\r\n```tcl\r\npackage require -exact testcl 1.0.9\r\nnamespace import testcl::*\r\n\r\nbefore {\r\n  event HTTP_REQUEST\r\n  class configure blacklist {\r\n    \"blacklisted\" \"192.168.6.66\"\r\n  }\r\n}\r\n\r\nit \"should drop blacklisted addresses\" {\r\n  on IP::remote_addr return \"192.168.6.66\"\r\n  endstate drop\r\n  run irules/classes.tcl classes\r\n}\r\n\r\nit \"should drop blacklisted addresses\" {\r\n  on IP::remote_addr return \"192.168.0.1\"\r\n  endstate pool main-pool\r\n  run irules/classes.tcl classes\r\n}\r\n```\r\n\r\n## How stable is this code?\r\nThis work is quite stable, but you can expect minor breaking changes.\r\n\r\n## Why I created this project\r\n\r\nConfiguring BIG-IP devices is no trivial task, and typically falls in under a DevOps kind of role.\r\nIn order to make your system perform the best it can, you need:\r\n\r\n- In-depth knowledge about the BIG-IP system (typically requiring at least a [$2,000 3-day course](https://f5.com/education/training))\r\n- In-depth knowledge about the web application being load balanced \r\n- The Tcl language and the iRule extensions\r\n- And finally: _A way to test your iRules_\r\n\r\nMost shops test iRules [manually](http://en.wikipedia.org/wiki/Manual_testing), the procedure typically being a variation of the following:\r\n\r\n- Create/edit iRule\r\n- Add log statements that show execution path\r\n- Push iRule to staging/QA environment\r\n- Bring backend servers up and down **manually** as required to test fallback scenarios\r\n- Generate HTTP-traffic using a browser and verify **manually** everything works as expected\r\n- Verify log entries **manually**\r\n- Remove or disable log statements\r\n- Push iRule to production environment\r\n- Verify **manually** everything works as expected \r\n\r\nThere are lots of issues with this **manual** approach:\r\n\r\n- Using log statements for testing and debugging messes up your code, and you still have to look through the logs **manually**\r\n- Potentially using different iRules in QA and production make automated deployment procedures harder\r\n- Bringing servers up and down to test fallback scenarios can be quite tedious\r\n- **Manual** verification steps are prone to error\r\n- **Manual** testing takes a lot of time\r\n- Development roundtrip-time is forever, since deployment to BIG-IP sometimes can take several minutes\r\n\r\nClearly, **manual** testing is not the way forward!\r\n\r\n## Test matrix and compatibility\r\n\r\n|               | Mac Os X | Windows| Cygwin |\r\n| ------------- |----------|--------|--------|\r\n| JTcl  2.4.0   | yes      | yes    | yes    |\r\n| JTcl  2.5.0   | yes      | yes    | yes    |\r\n| JTcl  2.6.0   | yes      | yes    | yes    |\r\n| Tclsh 8.6     | yes*     | yes*   | ?      |\r\n\r\nThe * indicates support only for standard Tcl commands\r\n\r\nIf you use TesTcl on a different platform, please let us know\r\n\r\n## Getting help\r\n\r\nPost questions to the group at [TesTcl user group](https://groups.google.com/forum/?fromgroups#!forum/testcl-user)  \r\nFile bugs over at [github](https://github.com/landro/TesTcl)\r\n\r\n## Contributing code\r\n\r\nContributions are very welcomed. There are just a few things to remember:\r\n\r\n - Run tests against JTcl since the custom iRule extensions have only been implemented in that Tcl implementation\r\n    - Run _examples.sh_ and _tests.sh_ or their Windows equivalents, and verify output\r\n - Please follow existing coding style and indentation (2 spaces for tabs)\r\n - Add new example or test when appropriate\r\n - Add or update documentation when necessary and make sure it is correct (as in test it)\r\n\r\n## Who uses it?\r\n\r\nWell, I can't really tell you, but according to Google Analytics, this site gets around 5 hits per day.\r\n\r\n## License\r\n\r\nJust like JTcl, TesTcl is licensed under a BSD-style license. \r\n\r\n## Please please please\r\n\r\nDrop me a line if you use this library and find it useful: stefan.landro **you know what** gmail.com\r\n\r\nYou can also check out [my LinkedIn profile](http://no.linkedin.com/in/landro) or \r\n[my Google+ profile](https://plus.google.com/114497086993236232709?rel=author), or \r\neven [my twitter account - follow it for TesTcl releases](https://twitter.com/landro)\r\n",
  "google": "UA-33046216-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}